### 문제
* 코드트리 intermediate low (숫자가 가장 큰 인접한 곳으로 동시에 이동 문제와 유사)
* n*n 이하의 숫자들이 정확히 한번씩만 등장하는 n*n 크기의 격자판 정보가 주어진다.
* m번의 턴에 걸쳐 숫자들을 이동하는데, 한 번의 턴에 1~n*n이 적힌 위치까지 순서대로 하나씩 본다.
* 각 위치에서 여덟방향으로 움직여서 가장 큰 숫자 있는 위치와 현재 위치의 값을 바꿔준다. 

### 입력
* 격자의 크기를 나타낸 n, 턴의 수 m (2 ≤ n ≤ 20, 1 ≤ m ≤ 100)
* n개의 줄에 걸쳐 각 행의 숫자들

### 출력
* m번의 턴을 거친 이후 격자판의 상태

```python
n, m = map(int, input().split())
info = [list(map(int, input().split())) for _ in range(n)]


def in_range(x, y):
    return 0 <= x < n and 0 <= y < n


def get_max(x, y):
    dxs = [-1, 1, 0, 0, -1, 1, -1, 1]
    dys = [0, 0, -1, 1, 1, 1, -1, -1]

    max_num = 0

    for dx, dy in zip(dxs, dys):
        next_x, next_y = x + dx, y + dy
        if in_range(next_x, next_y) and info[next_x][next_y] > max_num:
            max_num = info[next_x][next_y]
            max_pos = next_x, next_y

    return max_pos


def simulate():
    cnt = 1
    while cnt <= n*n :
        for i in range(n):
            for j in range(n):
                if info[i][j] == cnt:
                    next_x, next_y = get_max(i, j)
                    info[i][j] = info[next_x][next_y]
                    info[next_x][next_y] = cnt
                    cnt += 1

for _ in range(m):
    simulate()

for i in info:
    print(*i)
```
