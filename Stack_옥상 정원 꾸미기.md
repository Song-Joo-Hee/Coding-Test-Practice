### 문제
* 백준 6198번<br>

n개의 빌딩이 일렬로 서있고, i번째 빌딩 관리인이 볼 수 있는 다른 빌딩의 옥상 정원은 i+1, i+2, .... , n이다.
그런데 자신이 위치한 빌딩보다 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.

### 입력
1. 첫번째 줄 : 빌딩의 개수 n (1 ≤ N ≤ 80,000)
2. 두번째 줄 ~ : 각 빌딩의 높이 h (1 ≤ hi ≤ 1,000,000,000)

### 출력
1. 각 관리인들이 벤치마킹이 가능한 빌딩의 수의 합

### 아이디어(풀이 봤음)
1. 스택을 이용하는데,  h 만큼 for문을 돌면서 자기 자신부터 스택에 넣는다. 
2. 근데 현재 값보다 큰 값이 나올때까지 스택에서 뺀다. 

### 시간복잡도
1. for문을 n만큼 돌고, 스택을 n-

### 자료구조
1. 스택 : []
2. ans = 0 

```python
import sys
input = sys.stdin.readline

n = int(input())

h = [int(input()) for _ in range(n)]

stack = []
answer = 0

for i in range(n):
    while stack and stack[-1] <= h[i]: # 스택이 비어있지 않고, 현재 값이 스택의 마지막 값보다 클 때까지
        stack.pop() 
    stack.append(h[i]) 
    answer += len(stack) -1 # 자기 자신을 빼줘야 한다.
    
print(answer)
```
<br>
👉 사실 코드를 봤을 때, 이해가 가지 않아서 한참동안 코드를 봤다. 실제 코테였다면, 이렇게 생각해서 푸는게 많이 어려웠을듯.. <br>
👉 구현의 문제가 아니면, 문제 그대로 받아들일 때 잘 풀리지 않는다면 생각의 전환을 해볼 필요가 있다는 것을 알게 되었다. 
