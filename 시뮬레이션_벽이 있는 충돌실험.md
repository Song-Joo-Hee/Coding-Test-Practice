### 문제
* 코드트리 intermediate
* 테스트 케이스 t가 주어지고, 각 테스트 케이스마다 격자 n, 구슬정보가 주어진다.
* 각 구슬은 방향을 가지고 있고, 그 방향대로 1초씩 움직인다. 
* 오랜 시간이 지난 후, 남은 구슬의 개수를 구하여라.
* 이 때, 벽에 부딪혔을때는 방향을 반대로 바꿔준다. 이 역시 1초가 소요된다.
* 서로 같은 위치에 만나 충돌할 경우, 충돌한 모든 구슬은 사라진다.

### 아이디어
* mapper를 사용하여 각 방향마다 숫자를 부여한다. 

```python
t = int(input())

mapper = {
    'U': 0,
    'R': 1,
    'L': 2,
    'D': 3
}


def in_range(x, y):
    return 0 < x <= n and 0 < y <= n


def move(marble):
    # mapper 순으로
    dxs = [-1, 0, 0, 1]
    dys = [0, 1, -1, 0]

    x, y, move_dir = marble

    nx, ny = x + dxs[move_dir], y + dys[move_dir]

    if in_range(nx, ny):
        return (nx, ny, move_dir)
    else:
        return (x, y, 3 - move_dir)


def move_all():
    for i, marble in enumerate(marbles):
        marbles[i] = move(marble)  # 구슬 정보가 들어있는 배열의 정보를 바꿔준다.


def duplicate_exist(idx):
    target_x, target_y, _ = marbles[idx]
    return marbles_cnt[target_x][target_y] >= 2


def remove_duplicate():
    global marbles

    # 현재 구슬이 있는 위치 표시해주기
    for x, y, _ in marbles:
        marbles_cnt[x][y] += 1

    # 남아 있는 구슬만 새로운 배열에 담아주기
    remaining_marbles = [
        marble
        for i, marble in enumerate(marbles)
        if not duplicate_exist(i)
    ]

    # 현재 구슬이 있는 위치 다시 초기화
    for x, y, _ in marbles:
        marbles_cnt[x][y] = 0

    # 구슬 정보 배열에 남아 있는 구슬만 담아주기
    marbles = remaining_marbles


def simulate():
    # 모든 구슬 움직이기
    move_all()

    # 충돌된 구슬 없애기
    remove_duplicate()


for _ in range(t):
    n, m = map(int, input().split())
    marbles = []

    marbles_cnt = [
        [0 for _ in range(n + 1)]
        for _ in range(n + 1)
    ]

    for _ in range(m):
        x, y, d = input().split()
        x, y = int(x), int(y)
        marbles.append((x, y, mapper[d]))

    for _ in range(2 * n):
        simulate()

    print(len(marbles))
```
